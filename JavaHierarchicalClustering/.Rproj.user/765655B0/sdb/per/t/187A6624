{
    "contents" : "#This uses k-fold partitioning to divide up the presences, and uses a train and test\n#background/pseudoabsence without partitioning.\nEvaluatePOModel <- function(folds, covs.pres, covs.bkg.train, covs.bkg.test, mxnt.args, path){\n  results<-data.frame(n.train=rep(0,folds), n.test=0, nparams=0, train.auc=0,\n                      test.auc=0, stringsAsFactors=FALSE)\n  kvector <- kfold(covs.pres, folds)\n  \n  for (k in 1:folds){\n    n.train <- length(which(kvector!=k))\n    n.test <- length(which(kvector==k))\n    train.df <- rbind(covs.pres[kvector!=k, ], covs.bkg.train)\n    test.df <- rbind(covs.pres[kvector==k, ], covs.bkg.test)\n    y.train <- c(rep(1, n.train),rep(0,nrow(covs.bkg.train)))\n    y.test <- c(rep(1, n.test),rep(0,nrow(covs.bkg.test)))\n    mxnt.obj <- maxent(x=train.df, p=y.train, removeDuplicates=FALSE, args=mxnt.args, path=path)\n    pocc.train <- predict(mxnt.obj, train.df)\n    pocc.test <- predict(mxnt.obj, test.df)\n    auc.train <- evaluate(pocc.train[y.train==1], pocc.train[y.train==0])@auc\n    auc.test <- evaluate(pocc.test[y.test==1], pocc.test[y.test==0])@auc\n    nparams <- sum(getLambdaTable(mxnt.obj@lambdas)[, 2] != 0)\n    results[k, ]<-c(n.train, n.test, nparams, auc.train, auc.test)\n  }\n  return(results)\n}\n\ngetLambdaTable<-function(lambdas){\n  lambdas.list <- strsplit(lambdas,\",\")\n  nparams = length(lambdas) - 4\n  varnames=rep(\"NA\",nparams)\n  result<-data.frame(lambdas=rep(0,nparams))\n  for (i in 1:nparams){\n    varnames[i]<-lambdas.list[[i]][1]\n    result[i,1]<-as.numeric(lambdas.list[[i]][2])\n  }\n  result<-data.frame(varnames,result,stringsAsFactors=F)\n  return(result)\n}\n\n\nOptimizeLambda <- function(folds, covs.pres, covs.bkg.train, covs.bkg.test, mxnt.args, wd=getwd(), sp.prefix=\"species\", path){\n  lambda.vector <- c(0.02,0.05,0.1,0.22,0.46,1,2.2,4.6)\n  results <-data.frame()\n  for(lambda in lambda.vector){\n    mxnt.args <- c(mxnt.args,paste0(\"betamultiplier=\",lambda))\n    results <- rbind(results, \n                     EvaluatePOModel(folds, covs.pres, covs.bkg.train, covs.bkg.test, mxnt.args,path=path))\n  }\n  results <- cbind(lambda=rep(lambda.vector,each=folds), results)\n  write.csv(results, paste0(wd, \"/\", sp.prefix, \"_lambda.optimization.csv\"), row.names=FALSE)\n  lambda.params <- FindBestLambda(results)\n  return(lambda.params)\n}\n\nFindBestLambda<-function(df){\n  summary.df <- ddply(df, \"lambda\", summarise, mean.auc=mean(test.auc),\n                      median.auc=median(test.auc, na.rm=TRUE),mean.nparams=mean(nparams))\n  best.lambda <- summary.df$lambda[which.max(summary.df$median.auc)]\n  optimum.lambda <- NA\n  opt.idx <- NA\n  start.idx <- which.max(summary.df$median.auc) + 1\n  if(start.idx > nrow(summary.df)){\n    result=c(best.lambda = best.lambda, \n             best.nparams = summary.df$mean.nparams[(start.idx-1)],\n             best.median.auc = max(summary.df$median.auc),\n             optimum.lambda = NA,\n             optimum.nparams = NA,\n             optimum.median.auc = NA)\n    return(result)\n  }\n  for(i in start.idx:nrow(summary.df)){\n    pval <- with(df,\n                 wilcox.test(test.auc[lambda == best.lambda], test.auc[lambda == summary.df$lambda[i]],\n                             alternative=\"greater\", paired=F)$p.value)\n    if(pval<0.05){\n      opt.idx <- (i-1)\n      optimum.lambda <- summary.df$lambda[opt.idx]\n      break\n    }\n  }\n  if(is.na(opt.idx)){\n    result=c(best.lambda = best.lambda, \n             best.nparams = summary.df$mean.nparams[(start.idx-1)],\n             best.median.auc = max(summary.df$median.auc),\n             optimum.lambda = NA,\n             optimum.nparams = NA,\n             optimum.median.auc = NA)\n  } else {\n    result=c(best.lambda = best.lambda,\n             best.nparams = summary.df$mean.nparams[(start.idx-1)],\n             best.median.auc = max(summary.df$median.auc),\n             optimum.lambda = optimum.lambda,\n             optimum.nparams = summary.df$mean.nparams[opt.idx],\n             optimum.median.auc = summary.df$median.auc[opt.idx])\n  }\n  return(result)\n}\n\n \n  \n  \n",
    "created" : 1418664310218.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2798030715",
    "id" : "187A6624",
    "lastKnownWriteTime" : 1409953570,
    "path" : "D:/Trabajo/201420/Humboldt/RevisionCodigo/parallelMaxent-master/evaluationFunctions.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}